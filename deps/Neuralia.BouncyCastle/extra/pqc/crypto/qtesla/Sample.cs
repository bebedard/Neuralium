using System;
using System.IO;

namespace Neuralia.BouncyCastle.extra.pqc.crypto.qtesla {

	public class Sample {

		internal static readonly double[][] EXPONENTIAL_DISTRIBUTION_I = {new[] {1.0000000000000000000000000000000000000000, 0.9990496327075997720621566739241504871513, 0.9981001686131900082646604498429491608001, 0.9971516068584008799087793737854343387385, 0.9962039465856783249057599531380206128030, 0.9952571869382832724989228009014122394200, 0.9943113270602908687225570427678069689363, 0.9933663660965897025969132575731249565771, 0.9924223031928810330585953871541593536283, 0.9914791374956780166256527164832613053574, 0.9905368681523049357966736891640434381216, 0.9895954943108964281831839869512129866330, 0.9886550151203967163746519649066284074237, 0.9877154297305588385354051961226109899227, 0.9867767372919438797327625416330343864518, 0.9858389369559202039956868221933583419625, 0.9849020278746626871032638290431658501235, 0.9839660092011519501023140705695025630520, 0.9830308800891735935534443109670000387768, 0.9820966396933174325048466155419862577528, 0.9811632871689767321931532752331431453491, 0.9802308216723474444706566402213564033800, 0.9792992423604274449582035491768120172661, 0.9783685483910157709230746967427200384407, 0.9774387389227118598811599372828827520575, 0.9765098131149147889227411777252636721429, 0.9755817701278225147611951665163479411869, 0.9746546091224311145039291392620050672727, 0.9737283292605340271448629345703623656609, 0.9728029297047212957777718459314622781631, 0.9718784096183788105298051271677986565965, 0.9709547681656875522144957200697952895280}, new[] {1.0000000000000000000000000000000000000000, 0.9700320045116228367035774232914930379400, 0.9409620897768370674212298508058219852849, 0.9127633421156708668942503744059309052528, 0.8854096543971923811501043960464255901147, 0.8588757018688517364879932717859212289637, 0.8331369187101692180902460141030849026557, 0.8081694752890624155161689578277768341910, 0.7839502560997556536888618983783791053116, 0.7604568383618460545183896873859249753543, 0.7376674712607126902372883387750345338472, 0.7155610558100490615694685434237323547987, 0.6941171253178751117406951384261687867164, 0.6733158264379437043232142381368341940533, 0.6531379007889984662634253213819854052726, 0.6335646671248656289427239706049936967143, 0.6145780040388724765036124496076447154217, 0.5961603331865797040852326968966728810261, 0.5782946030112948570545930362131434268247, 0.5609642729572995100665682618108293115511, 0.5441532981561743827978648643747061873131, 0.5278461145720445955231454653404664082188, 0.5120276245919921478529972155927751107378, 0.4966831830482948512984566287866591847562, 0.4817985836595507424420546966358580262381, 0.4673600458781348185224193866260805625424, 0.4533542021318111302275642196084653301628, 0.4397680854476881857303133336231578259611, 0.4265891174470596033395475021945475958821, 0.4138050967000153253100465421861800587782, 0.4014041874290417902572763743098032661210, 0.3893749085511525646401543103372782315254}, new[] {1.0000000000000000000000000000000000000000000, 0.3777061230484043540417651455683576466650000, 0.1426619153882563708052119679085105421822000, 0.0538842789679578114076165050703859298545800, 0.0203524221022460198907862721163275696205800, 0.0076872344468839996101743286763347159496400, 0.0029035155198967005412614828182250511400990, 0.0010966755902310549151227158892825815595730, 0.0004142210854279922997296008273437255752956, 0.0001564538402619088712753422615493598849163, 5.909357344135995142394679824207999201121E-5, 2.232000452161222135025591154935960584027E-5, 8.430402374281007236700902260035220289887E-6, 3.184214596527742337148476455363347356131E-6, 1.202697350208632670782595114365065060885E-6, 4.542661533478916755570208360842380811059E-7, 1.715791076131440947144583312662638239090E-7, 6.480647953266561572601959656715022445021E-8, 2.447780413269889735078224512008720987199E-8, 9.245416499699910342143072277116651273927E-9, 3.492050422069402212293514861017928736701E-9, 1.318968826409377991494549187659977485249E-9, 4.981826018447900060525041555590742055479E-10, 1.881666191129624879723808164319051826703E-10, 7.107168419228284402686789774896404982106E-11, 2.684421029478771850078976357840397379201E-11, 1.013922259674033292202917547107956246173E-11, 3.829646457739566105989785588606755995719E-12, 1.446480916198866420590826731657500079699E-12, 5.463446989209777070985952848270039796153E-13, 2.063577380774902353530525926195322827410E-13, 7.794258121028692337871970872695782456164E-14}};

		internal static readonly double[][] EXPONENTIAL_DISTRIBUTION_III = {new[] {1.0000000000000000000000000000000000000000, 0.9951980443443537316500388424172839303752, 0.9904191474668262564830185894967173613892, 0.9856631986401875746675941557587114196642, 0.9809300876689149347041557365309129923940, 0.9762197048866395987965541168345276706016, 0.9715319411536058687432894158212596709598, 0.9668666878541423134736924881553750396380, 0.9622238368941451396373408016639000521875, 0.9576032806985736469363056351479270970296, 0.9530049122089577101698314104664824876542, 0.9484286248809172302397073765744987564880, 0.9438743126816934966419131566675496907225, 0.9393418700876924042461092785035073150884, 0.9348311920820394674392081270253399758265, 0.9303421741521465749826061515830447550861, 0.9258747122872904292046909607697858626672, 0.9214287029762026134209634491584644007645, 0.9170040432046712317435415947941667461407, 0.9126006304531540657099452867877830194818, 0.9082183626944031924279067014123113094560, 0.9038571383911010091985145255388756529519, 0.8995168564935076098442888811876009946339, 0.8951974164371194582318032579854959087286, 0.8908987181403393047402262055905414183192, 0.8866206620021572916876550405654798379036, 0.8823631488998431939863624175501337704454, 0.8781260801866497415560803096876886684788, 0.8739093576895269702812107160640808580937, 0.8697128837068475485533842136704059167642, 0.8655365610061430266950922187780245940470, 0.8613802928218509568132024098758678171240}, new[] {1.000000000000000000000000000000000000000000, 0.857243982853072830883035055416073116703300, 0.734867246137799425692104349091725698937400, 0.629960524947436582383605303639195946052600, 0.540029869446153084936465415644391919699900, 0.462937356143645214602345480384983067321600, 0.396850262992049868687926409818180089809000, 0.340197500043594241063920093831306311583500, 0.291632259894029145223423158665267961335500, 0.250000000000000000000000000000097352251700, 0.214310995713268207720758763854101733807800, 0.183716811534449856423026087273002965715400, 0.157490131236859145595901325909860314588700, 0.135007467361538271234116353911150553048700, 0.115734339035911303650586370096290834824400, 0.099212565748012467171981602454583656718920, 0.085049375010898560265980023457859696888520, 0.072908064973507286305855789666345381391030, 0.062500000000000000000000000000048676125830, 0.053577748928317051930189690963546297109930, 0.045929202883612464105756521818268626674130, 0.039372532809214786398975331477480410666060, 0.033751866840384567808529088477800781543110, 0.028933584758977825912646592524083975704600, 0.024803141437003116792995400613655572746400, 0.021262343752724640066495005864473203970290, 0.018227016243376821576463947416593443112050, 0.015625000000000000000000000000018253547190, 0.013394437232079262982547422740891790191980, 0.011482300720903116026439130454571627979850, 0.009843133202303696599743832869373935671238, 0.008437966710096141952132272119453481206014}, new[] {1.000000000000000000000000000000000000000, 0.007233396189744456478161648131023810675775, 5.232202043780962102557587008169005410143E-5, 3.784659032745836912993682954976324658164E-7, 2.737593822694567686662466634421542264066E-9, 1.980210072614684707158711353745069372717E-11, 1.432364399414465384287735340977513952565E-13, 1.036085918905020069841154248521752033776E-15, 7.494419938055456100418425186702743722723E-18, 5.421010862427522170037264004417260251684E-20, 3.921231931684654880817938739668273317360E-22, 2.836382411375207747860568187463889509638E-24, 2.051667772709962123314993704273413823620E-26, 1.484052584974173558955043468582713624191E-28, 1.073474031353259824558654154333806911547E-30, 7.764862968180290824468612020607860317513E-33, 5.616633020792314645332222710264644852793E-35, 4.062733189179202535382045195211707654781E-37, 2.938735877055718769921841343128853888538E-39, 2.125704089576016965228859756656407540404E-41, 1.537605986206336992222535387300608525931E-43, 1.112211328195318530448364746285024038827E-45, 8.045065183558638234146057828832053516826E-48, 5.819314384499884015403474144560288801662E-50, 4.209340649576656799996170991423257963815E-52, 3.044782861598424467581974062513986546956E-54, 2.202412074968526631812431321732133496007E-56, 1.593091911132452277028880397827266782094E-58, 1.152346495989819456843455045622426762614E-60, 8.335378753358135655955994470664225877261E-63, 6.029309691461763611680553229574282672923E-65, 4.361238574900884540660050746922306538111E-67}};

		internal static readonly double[][] EXPONENTIAL_DISTRIBUTION_V = {new[] {1.0000000000000000000000000000000000000000, 0.9951980443443537316500388424172839303752, 0.9904191474668262564830185894967173613892, 0.9856631986401875746675941557587114196642, 0.9809300876689149347041557365309129923940, 0.9762197048866395987965541168345276706016, 0.9715319411536058687432894158212596709598, 0.9668666878541423134736924881553750396380, 0.9622238368941451396373408016639000521875, 0.9576032806985736469363056351479270970296, 0.9530049122089577101698314104664824876542, 0.9484286248809172302397073765744987564880, 0.9438743126816934966419131566675496907225, 0.9393418700876924042461092785035073150884, 0.9348311920820394674392081270253399758265, 0.9303421741521465749826061515830447550861, 0.9258747122872904292046909607697858626672, 0.9214287029762026134209634491584644007645, 0.9170040432046712317435415947941667461407, 0.9126006304531540657099452867877830194818, 0.9082183626944031924279067014123113094560, 0.9038571383911010091985145255388756529519, 0.8995168564935076098442888811876009946339, 0.8951974164371194582318032579854959087286, 0.8908987181403393047402262055905414183192, 0.8866206620021572916876550405654798379036, 0.8823631488998431939863624175501337704454, 0.8781260801866497415560803096876886684788, 0.8739093576895269702812107160640808580937, 0.8697128837068475485533842136704059167642, 0.8655365610061430266950922187780245940470, 0.8613802928218509568132024098758678171240}, new[] {1.000000000000000000000000000000000000000000, 0.857243982853072830883035055416073116703300, 0.734867246137799425692104349091725698937400, 0.629960524947436582383605303639195946052600, 0.540029869446153084936465415644391919699900, 0.462937356143645214602345480384983067321600, 0.396850262992049868687926409818180089809000, 0.340197500043594241063920093831306311583500, 0.291632259894029145223423158665267961335500, 0.250000000000000000000000000000097352251700, 0.214310995713268207720758763854101733807800, 0.183716811534449856423026087273002965715400, 0.157490131236859145595901325909860314588700, 0.135007467361538271234116353911150553048700, 0.115734339035911303650586370096290834824400, 0.099212565748012467171981602454583656718920, 0.085049375010898560265980023457859696888520, 0.072908064973507286305855789666345381391030, 0.062500000000000000000000000000048676125830, 0.053577748928317051930189690963546297109930, 0.045929202883612464105756521818268626674130, 0.039372532809214786398975331477480410666060, 0.033751866840384567808529088477800781543110, 0.028933584758977825912646592524083975704600, 0.024803141437003116792995400613655572746400, 0.021262343752724640066495005864473203970290, 0.018227016243376821576463947416593443112050, 0.015625000000000000000000000000018253547190, 0.013394437232079262982547422740891790191980, 0.011482300720903116026439130454571627979850, 0.009843133202303696599743832869373935671238, 0.008437966710096141952132272119453481206014}, new[] {1.000000000000000000000000000000000000000, 0.007233396189744456478161648131023810675775, 5.232202043780962102557587008169005410143E-5, 3.784659032745836912993682954976324658164E-7, 2.737593822694567686662466634421542264066E-9, 1.980210072614684707158711353745069372717E-11, 1.432364399414465384287735340977513952565E-13, 1.036085918905020069841154248521752033776E-15, 7.494419938055456100418425186702743722723E-18, 5.421010862427522170037264004417260251684E-20, 3.921231931684654880817938739668273317360E-22, 2.836382411375207747860568187463889509638E-24, 2.051667772709962123314993704273413823620E-26, 1.484052584974173558955043468582713624191E-28, 1.073474031353259824558654154333806911547E-30, 7.764862968180290824468612020607860317513E-33, 5.616633020792314645332222710264644852793E-35, 4.062733189179202535382045195211707654781E-37, 2.938735877055718769921841343128853888538E-39, 2.125704089576016965228859756656407540404E-41, 1.537605986206336992222535387300608525931E-43, 1.112211328195318530448364746285024038827E-45, 8.045065183558638234146057828832053516826E-48, 5.819314384499884015403474144560288801662E-50, 4.209340649576656799996170991423257963815E-52, 3.044782861598424467581974062513986546956E-54, 2.202412074968526631812431321732133496007E-56, 1.593091911132452277028880397827266782094E-58, 1.152346495989819456843455045622426762614E-60, 8.335378753358135655955994470664225877261E-63, 6.029309691461763611680553229574282672923E-65, 4.361238574900884540660050746922306538111E-67}};

		internal static readonly double[][] EXPONENTIAL_DISTRIBUTION_P = {new[] {1.0000000000000000000000000000000000000000, 0.9930924954370359015332102168880765048173, 0.9862327044933591729073804985266878802443, 0.9794202975869268710835182321094224250961, 0.9726549474122855185227020947295413763023, 0.9659363289248455510651443129204733029988, 0.9592641193252643901322834293949397264660, 0.9526379980439373889289005948680289570903, 0.9460576467255959075051119972754354254470, 0.9395227492140117766851490088262829075331, 0.9330329915368074159813432661499603336007, 0.9265880618903708756879317851202732375877, 0.9201876506248750783904312382017973974891, 0.9138314502294005401326428921359892449876, 0.9075191553171608564550809482180658363403, 0.9012504626108302434560060155923701020040, 0.8950250709279724289295293992056807493013, 0.8888426811665701935046683790031660959701, 0.8827029962906548665450116490541232503509, 0.8766057213160350863710299119436526437378, 0.8705505632961241391362700174797799990040, 0.8645372313078651954249311342751209858410, 0.8585654364377537683418658040230197384022, 0.8526348917679567215371033354114150564474, 0.8467453123625271602457822707284519309456, 0.8408964152537145430311254762332558266219, 0.8350879194283693564930171007187976000468, 0.8293195458144416997480650199452263126561, 0.8235910172675731299989737240342361894393, 0.8179020585577811249918276889374069238047, 0.8122523963562355226097093827753290960475, 0.8066417592221263022701629871861700330324}, new[] {1.000000000000000000000000000000000000000000, 0.801069877589622077182576980035615205902700, 0.641712948781452099037917089781420222618900, 0.514056913328033254673172479396413573907600, 0.411795508633786564999486862017198273163900, 0.329876977693223564843500492807512798916800, 0.264254510140345093624873553521627364440900, 0.211686328090631790061445567682195415303500, 0.169575540930958985396762834141244920349500, 0.135841857815757262606900740466230788178000, 0.108818820412015517392033752185036062422000, 0.087171479146900338767218235365499637556050, 0.069830446129513747913186914700207350540810, 0.055939066932998276808095587450398613186620, 0.044811101500494605684562734558780780465070, 0.035896823593657343962457092086843785683310, 0.028755864082027346199700976193834163154190, 0.023035456520173456442055699495851578765410, 0.018453010334836412492976026695119689178670, 0.014782150730087436054767374957445947431420, 0.011841535675862485018337967197721359270050, 0.009485897534336303604787967133085469399049, 0.007598866776658480613458610115084898737984, 0.006087223278597655149117219956228990612855, 0.004876291206646921576592633968279399063782, 0.003906250000000000000000000000006084516053, 0.003129179209334461238994441328268996020587, 0.002506691206177547261866863631962577257343, 0.002008034817687629901067079997645368310618, 0.001608576205600728769529245554757186330929, 0.001288581944114154550169923800031354012535, 0.001032244180235723021972162318445464753156}, new[] {1.000000000000000000000000000000000000000, 0.0008268997191040304299275217487598638498908, 6.837631454543244275598561791827450446268E-7, 5.654035529098691704742888887601969318770E-10, 4.675320390815916240837145591289455678271E-13, 3.866021117887026910581260785663924052584E-16, 3.196811776431032265107748321378670183434E-19, 2.643442759959277106397015416454182808165E-22, 2.185862075677909177530183421677021601630E-25, 1.807488736378216004902267757945329990433E-28, 1.494611928394845722509566662381681852231E-31, 1.235894183759231170477230799378805483584E-34, 1.021960553392813221805059629881904702629E-37, 8.450588945359167454685108853553438401193E-41, 6.987789625181120323479538530531788834637E-44, 5.778201278220326478541087516212630539830E-47, 4.777993013886937548374901071454718579294E-50, 3.950921081064128423947108109095179681258E-53, 3.267015532134120033414586853048549151733E-56, 2.701494225830208356330596231491229575841E-59, 2.233864816500159437321055999997722887780E-62, 1.847182189280358319436455385107649366142E-65, 1.527434433449896263866613728025637317872E-68, 1.263035103969543081968346060350962609985E-71, 1.044403372690945043917523022329044283453E-74, 8.636168555094444625386351863230863826745E-78, 7.141245352342656606906053992842560076147E-81, 5.905093775905105564186232605424573035226E-84, 4.882920384578890205960673105845289217904E-87, 4.037685494415628551550334502904113261957E-90, 3.338761001162701476381524668052565130775E-93, 2.760820534016929266476966660680800456743E-96}};

		internal static readonly long[][] CUMULATIVE_DISTRIBUTION_TABLE_I = {new[] {0x0200000000000000L, 0x0000000000000000L}, new[] {0x0300000000000000L, 0x0000000000000000L}, new[] {0x0320000000000000L, 0x0000000000000000L}, new[] {0x0321000000000000L, 0x0000000000000000L}, new[] {0x0321020000000000L, 0x0000000000000000L}, new[] {0x0321020100000000L, 0x0000000000000000L}, new[] {0x0321020100200000L, 0x0000000000000000L}, new[] {0x0321020100200100L, 0x0000000000000000L}, new[] {0x0321020100200100L, 0x0200000000000000L}, new[] {0x0321020100200100L, 0x0200010000000000L}, new[] {0x0321020100200100L, 0x0200010000200000L}, new[] {0x0321020100200100L, 0x0200010000200001L}};

		internal static readonly long[][] CUMULATIVE_DISTRIBUTION_TABLE_III = {new[] {0x0000020000000000L, 0x0000000000000000L, 0x0000000000000000L}, new[] {0x0000030000000000L, 0x0000000000000000L, 0x0000000000000000L}, new[] {0x0000032000000000L, 0x0000000000000000L, 0x0000000000000000L}, new[] {0x0000032100000000L, 0x0000000000000000L, 0x0000000000000000L}, new[] {0x0000032102000000L, 0x0000000000000000L, 0x0000000000000000L}, new[] {0x0000032102010000L, 0x0000000000000000L, 0x0000000000000000L}, new[] {0x0000032102010020L, 0x0000000000000000L, 0x0000000000000000L}, new[] {0x0000032102010020L, 0x0100000000000000L, 0x0000000000000000L}, new[] {0x0000032102010020L, 0x0100020000000000L, 0x0000000000000000L}, new[] {0x0000032102010020L, 0x0100020001000000L, 0x0000000000000000L}, new[] {0x0000032102010020L, 0x0100020001000020L, 0x0000000000000000L}, new[] {0x0000032102010020L, 0x0100020001000020L, 0x0001000000000000L}, new[] {0x0000032102010020L, 0x0100020001000020L, 0x0001000002000000L}, new[] {0x0000032102010020L, 0x0100020001000020L, 0x0001000002000001L}};

		internal static readonly long[][] CUMULATIVE_DISTRIBUTION_TABLE_V = {new[] {0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L},new[] {0x05019F2342B5510CL, 0x4CD7B09465894A2CL, 0x6DE2DB0C83811B10L, 0x3AE75671119550F6L},new[] {0x0EF8936E477F8F22L, 0x6363208540D46A81L, 0x129AF6DC75D7D552L, 0x40D3083F0776CFE3L},new[] {0x18CB03FC0E8D84ADL, 0x00E045D0CD3E52EBL, 0x77C62B13CC57D9B7L, 0x01CF1C6012B9EA7CL},new[] {0x2261C15E8A4F57E3L, 0x799EC88203BDB518L, 0x2C9C121D809DB247L, 0x0F52FE08793084E7L},new[] {0x2BA749FE946E30ACL, 0x7459532F454F2C2BL, 0x3A1BF0B789C9A033L, 0x466E77DF61E89C7FL},new[] {0x3488598A086B65AFL, 0x1BB3215C39D0A702L, 0x5F1C249BBE8C05B9L, 0x6442D62162D3FBC0L},new[] {0x3CF45E2203C37E93L, 0x19FEB5DC9AB8A030L, 0x6D600A4CDDF47536L, 0x271565AF8D2DB36DL},new[] {0x44DDCECBB7D63DB2L, 0x57AF2F7EA464B594L, 0x07A2AA8AF2A92B7FL, 0x5C9770F8308B1E94L},new[] {0x4C3A608E45EF7B2BL, 0x775EBC95847A28B9L, 0x128C98F6E32A6AD7L, 0x10FB770D44E3367EL},new[] {0x530319A45556D18AL, 0x26B73633F467FE8CL, 0x3D2FB617807ED923L, 0x1FF6B0CCE4F60CD6L},new[] {0x59344411DF74E917L, 0x0813BEE3DB0A930AL, 0x162DF9EC58CFC393L, 0x41AC8E94DDE226D0L},new[] {0x5ECD42A3244B1CD9L, 0x6157B17ECFE35BE0L, 0x753A39FD754CC3E5L, 0x638EF3509DCD8197L},new[] {0x63D04CBC960744B4L, 0x2F1275FA0144B4F2L, 0x3404A308EED3511CL, 0x2EEBB6734F7B1ECFL},new[] {0x684216614F39B7E7L, 0x4976731B80EF6948L, 0x7BD5019EE6303797L, 0x0994751DB14391A6L},new[] {0x6C296A64B1A8024BL, 0x3ABC64091652340BL, 0x21782F64DD11F701L, 0x671FA5E9EDBC695EL},new[] {0x6F8EBCDC597936D8L, 0x0F1B7A484454DD08L, 0x664046C247C71B91L, 0x15D0FF975B219084L},new[] {0x727BBBA2C8C9C903L, 0x580749493EEFD962L, 0x787DFA828E66FCEEL, 0x5FD8D02CB2599090L},new[] {0x74FAE22164C29C97L, 0x16732C4B4A136721L, 0x4E1F6F9CDAA1C162L, 0x605CA00B7E0DCA39L},new[] {0x771714BEC9BCF02FL, 0x375FE580E9D6C097L, 0x6CF87018C3991EADL, 0x1BE9B45B575FD244L},new[] {0x78DB474CC920D694L, 0x6D82BA3526AA83EFL, 0x409804E30E0FDE1AL, 0x2C6D4B5E54B8BB4BL},new[] {0x7A5230BF426B2FE4L, 0x7D989CF77FF88728L, 0x2E99BFC73715F70CL, 0x6251B731F5EB8F7EL},new[] {0x7B860D681BA2F584L, 0x699C522E4F437855L, 0x76B8B0579219DEA6L, 0x50F1371301CF5F8FL},new[] {0x7C806FFEE0D1DF7BL, 0x4077BA0090A490A4L, 0x21BC2976959F59A8L, 0x4A405B2BD43A89B5L},new[] {0x7D4A20E95AB78E37L, 0x0E1EC99D8C4A7EBCL, 0x135351765631105BL, 0x183A03094DAE860BL},new[] {0x7DEB0A96014CA039L, 0x188C3427E432AE17L, 0x53F025F82F3DF57DL, 0x55438A8F7BCBB7E8L},new[] {0x7E6A3144EB926484L, 0x2C046AE21ADC442CL, 0x4CA302B8FA06FCB6L, 0x5A3C660C9738126DL},new[] {0x7ECDB456CC34FC6AL, 0x2C5CAA35D76E76A6L, 0x1A5D04A418E34582L, 0x5BA4C377B73C582CL},new[] {0x7F1AD71F40A2D63FL, 0x3FE015C50F7FC951L, 0x6E7AB9E0343340B4L, 0x23EBC5E506A532A1L},new[] {0x7F560F416601BCF9L, 0x171E0F3370F915D2L, 0x6CC15C205CB5C6E5L, 0x39B31A5ED2EF1A6BL},new[] {0x7F8316C3244DD5B7L, 0x23A1C16361C2526BL, 0x5118BD42B2B3A241L, 0x17BBF5A7F25B1EFFL},new[] {0x7FA5003C6307FD2DL, 0x2D4602BB51C738A5L, 0x0AD8D6C61C43A829L, 0x50C4916AADD91F4AL},new[] {0x7FBE4BCB46FF7D10L, 0x0C249EC26261DF42L, 0x232A94FC932F10D6L, 0x15F8CD8541D7FE4FL},new[] {0x7FD0FBBE92014AF6L, 0x24634E5085C4F545L, 0x08D0C74EDBC5FD91L, 0x3B3B8E7DCF1D999FL},new[] {0x7FDEA82D84C8D138L, 0x1217AA56D6CFBD62L, 0x178AF040E5E85D80L, 0x725E8A742BF203A0L},new[] {0x7FE890F4FE84F8B2L, 0x7FD4EF4FDAD73B12L, 0x165136C3218D5654L, 0x037B4B811465B818L},new[] {0x7FEFADC946A8C3E5L, 0x6CA61FCF162BFB58L, 0x580148764B6FBA95L, 0x2BE3E48B7D6F8C53L},new[] {0x7FF4BC398FAC532CL, 0x1018095D55E3A474L, 0x692D94B4F962B847L, 0x7E02BFC060CEE1DCL},new[] {0x7FF84BA5893D5909L, 0x07B04DF406BF3C54L, 0x20B9C520BA64B0B8L, 0x77A5CC0996BAE019L},new[] {0x7FFAC73ED164E46EL, 0x2065C7F38F7B589FL, 0x64280E849601334BL, 0x1709D3D22A760D97L},new[] {0x7FFC7E40D9B9C723L, 0x69A58DC15BD0E7E9L, 0x17869C657BDD3E9EL, 0x5DD81FE78955F1E8L},new[] {0x7FFDAA935414AF3FL, 0x1C7FAC7155551F41L, 0x77210594DB1F8EBEL, 0x2FB0BC24425B7837L},new[] {0x7FFE760EFA1B4632L, 0x095D3D1B1FE2D091L, 0x1E40543CA32C086EL, 0x03AC03212E0BE884L},new[] {0x7FFEFE9C01CDE231L, 0x36258D378C114612L, 0x35DB13F002A245D6L, 0x5DE449A40223499AL},new[] {0x7FFF595E2652C4B5L, 0x71198F3F86DCB271L, 0x223766E71A415745L, 0x0D18F1A0D8F47BE9L},new[] {0x7FFF951CF928EAB7L, 0x7E20A9BF5F5B8D45L, 0x555BD8D991550B88L, 0x4D5BB5246041EAD7L},new[] {0x7FFFBC111AC7BB32L, 0x2DC3BDDB7E91FF59L, 0x780B1FD494973B45L, 0x64CA85B1C3C71197L},new[] {0x7FFFD538ADF927F1L, 0x17EDEA3B9747D0BBL, 0x19851067A1CCCFA4L, 0x3BAFA9CDA334BF14L},new[] {0x7FFFE54F4DA4A32DL, 0x15EA26E9E8FC8135L, 0x4972F1B9AA347058L, 0x7357FC5B2ACACDB7L},new[] {0x7FFFEF804B8F1257L, 0x3F806D6F58F4BBD5L, 0x1CBC9E1307C48BD2L, 0x5BBCC6A3588C4C70L},new[] {0x7FFFF5E52EF2F773L, 0x15DA110757D1C239L, 0x3E3A785A156DE3BAL, 0x628A7904D4C6AE3CL},new[] {0x7FFFF9DE58F6B091L, 0x478FFA13C511566FL, 0x10BCE055DE131EA2L, 0x70A88B3C0A08F1BAL},new[] {0x7FFFFC505E46D85AL, 0x096716BB9F80C4D8L, 0x54165276AAF0B4D2L, 0x5866DC3D74E3A564L},new[] {0x7FFFFDCDF8B91533L, 0x0EF00E80F333EE23L, 0x1629296B13A169FFL, 0x7730B8C20B941ACFL},new[] {0x7FFFFEB45C3C9422L, 0x6CD593F8BE7A21EEL, 0x72B8C07A82980B27L, 0x67D0FD1FE3F32B0BL},new[] {0x7FFFFF3E1FD7A8DFL, 0x57839D0BCBC1A79BL, 0x699E7AB6690D5F43L, 0x0685143B089262CBL},new[] {0x7FFFFF8FB6DC913CL, 0x50EA31255B1E02D3L, 0x0B21AE8BB3CEF9F5L, 0x5445415249B83CD3L},new[] {0x7FFFFFBF92BD3CBFL, 0x7D543596D46C217DL, 0x7177F327819F8C53L, 0x5D7E6C8041578FECL},new[] {0x7FFFFFDB60AEC0F6L, 0x51C7094571495A81L, 0x4AB916A5A0C86892L, 0x732F040EC4834DACL},new[] {0x7FFFFFEB606B8B46L, 0x2B4F156E3F19C33DL, 0x6A40C7A8DB00C087L, 0x1F10A63B5FDC88F3L},new[] {0x7FFFFFF47E9B0F01L, 0x4DAA1A678ED72BFFL, 0x05654925F07F71CCL, 0x763DE365DD605F5FL},new[] {0x7FFFFFF9A425B9C5L, 0x59A08BAA1F779478L, 0x3ED10BE79355D8DBL, 0x4CA4A69D251646D1L},new[] {0x7FFFFFFC84B9D150L, 0x05E8C6F3A5010504L, 0x3785BB040EFE8A01L, 0x376F9AEABD12FAAFL},new[] {0x7FFFFFFE1C9328FEL, 0x1C0FD4EAED636FA9L, 0x321F9E78BA288325L, 0x5DA407D9BE9FB5D8L},new[] {0x7FFFFFFEFC3E6136L, 0x5E0EF14EB463A258L, 0x5B2FB495AF3173A4L, 0x5036F2B73BA56FE9L},new[] {0x7FFFFFFF75BB9523L, 0x3449872B5BA5C39EL, 0x1AB662754D243FB6L, 0x38BF844652D4600BL},new[] {0x7FFFFFFFB71712D3L, 0x67A0B22765E70755L, 0x7A1C37D25FB4402BL, 0x5AD937CDBB86F381L},new[] {0x7FFFFFFFD9EA002DL, 0x12E1D7FFECBE1D81L, 0x31D5BC6DBF422C24L, 0x317176B2F12411C6L},new[] {0x7FFFFFFFEC4AA4B8L, 0x15EF12504972F1F7L, 0x698BC95B8A1F3906L, 0x36401A4DE21177FBL},new[] {0x7FFFFFFFF5E5A897L, 0x0C33EF66C62BDBF0L, 0x5A0FDD635880924BL, 0x5EFC0307BB02A9E5L},new[] {0x7FFFFFFFFADEA35EL, 0x31A71BA3CF1D60A2L, 0x617F49A948FAFBDFL, 0x0212CADFC1AA2125L},new[] {0x7FFFFFFFFD6B542CL, 0x416291768F655BDFL, 0x6F56D71F93CA9BBDL, 0x7883DDAEB5BA7D2FL},new[] {0x7FFFFFFFFEB6C791L, 0x7BB655B09DCFAA60L, 0x442C34868392A5FDL, 0x33C2BDFCEBF8912CL},new[] {0x7FFFFFFFFF5D7CCFL, 0x45027FDFCCB6FCEEL, 0x37FF7277F6F831BDL, 0x0C37C6D5FD60ED73L},new[] {0x7FFFFFFFFFB0889EL, 0x5C0644ED6CABE864L, 0x116071BBCF03E5FAL, 0x6D714FF02096EC0AL},new[] {0x7FFFFFFFFFD981F5L, 0x2BF1A6C61FDE91C2L, 0x00C053120921BF05L, 0x286EA3E21D75624AL},new[] {0x7FFFFFFFFFED87C4L, 0x619F982C8554100CL, 0x25A3C8E02F8478D6L, 0x552360D5EF7D078FL},new[] {0x7FFFFFFFFFF738A1L, 0x3F77B9A4198D4D96L, 0x642278DCBEB74DD2L, 0x3B6756007FFCF3D6L},new[] {0x7FFFFFFFFFFBDDDEL, 0x1AB54B65D5BBE028L, 0x2411CB22929A07A4L, 0x187794524E2F6260L},new[] {0x7FFFFFFFFFFE127EL, 0x15DF5397C6E179A5L, 0x569F8A9D298FC824L, 0x09D51D371880D0EEL},new[] {0x7FFFFFFFFFFF1C00L, 0x13E6C9ECD285EB63L, 0x5AF604DAB41F9E71L, 0x07F6B73E0975D551L},new[] {0x7FFFFFFFFFFF97A8L, 0x39AA274972C789A6L, 0x64E76412E54D80DAL, 0x0506DF25C88B1405L},new[] {0x7FFFFFFFFFFFD0B3L, 0x0008D359D4C2B8B3L, 0x0A2B429CA0CB255FL, 0x62ED6005DB28B5E2L},new[] {0x7FFFFFFFFFFFEAC2L, 0x3F1317B61209848AL, 0x06328FAE3B3855ECL, 0x42F5885BC017651CL},new[] {0x7FFFFFFFFFFFF68DL, 0x2D2F2EFDF11E97EFL, 0x4F9D9FC479FFDD7DL, 0x57B3725EFDD464FDL},new[] {0x7FFFFFFFFFFFFBD6L, 0x298F5A37B7F38D6AL, 0x3EF4FB6D4A8CFDE3L, 0x5F8364FE6444F20EL},new[] {0x7FFFFFFFFFFFFE2EL, 0x71E53C0056193099L, 0x7B4724856EC1B2D6L, 0x7FAE931CCA85FC90L},new[] {0x7FFFFFFFFFFFFF36L, 0x760A7A8B9F413F15L, 0x18CEC22DE1B514BEL, 0x5A824F341807F14AL},new[] {0x7FFFFFFFFFFFFFA9L, 0x720C138B7A5B60FFL, 0x74C2757A4B42DC66L, 0x292C4CDD8874E22DL},new[] {0x7FFFFFFFFFFFFFDBL, 0x3C9BAB8FF63CE22AL, 0x3E9C9407AC8B1E1DL, 0x4B2DCCFB3331F190L},new[] {0x7FFFFFFFFFFFFFF0L, 0x5380B2C6191784F6L, 0x5C4E2D1B8241CFBFL, 0x723FA55F545A5272L},new[] {0x7FFFFFFFFFFFFFF9L, 0x4E5E4A10FF2D7097L, 0x57A3066FCDC93D34L, 0x2C9C45FB0984BAC3L},new[] {0x7FFFFFFFFFFFFFFDL, 0x2EEAF427CFC2DF3AL, 0x2E8A0F4A533B326FL, 0x4AC5FB1B496B51FDL},new[] {0x7FFFFFFFFFFFFFFEL, 0x7658E743AE8AD400L, 0x06BB7ABE65812498L, 0x2898F253187CEFB6L},new[] {0x7FFFFFFFFFFFFFFFL, 0x4851C6714099C670L, 0x1962C32895947421L, 0x67149810877FFC7DL},new[] {0x7FFFFFFFFFFFFFFFL, 0x69B0BF5176794C05L, 0x355CD7966FEF6E23L, 0x012B8E57E033B273L},new[] {0x7FFFFFFFFFFFFFFFL, 0x77255600113257E8L, 0x2A9694AFF1E3E4B9L, 0x00BA018A5C8965BAL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7C84EEFFC1569297L, 0x5E427B085390CCE7L, 0x6023B24771E20972L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7EA5062E79846C97L, 0x5EC39DA3B77AFB45L, 0x62F044057CDBCF2CL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7F7A2B7D64797F46L, 0x0A8E5A56BA9F01ECL, 0x4445D08131D78221L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FCCDECD3B50B2D5L, 0x16D1A0654FB2D79CL, 0x406BFDA97A2A2E73L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FECA6AEF047D604L, 0x7BA04CE45AA41B4CL, 0x60BB329AF39BF49CL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FF8BF4C4E9CB132L, 0x074B25D26BEA78A9L, 0x1BF0D2E33097BCEEL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFD4EA2021F85CBL, 0x1142057035EA4BA3L, 0x2D0345BAA017242EL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFF0279A258D215L, 0x358ACC67FB69B7A8L, 0x29D7E7F87F9DC25CL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFA3A59C429024L, 0x0D6D4FA75BAA60A6L, 0x3F24C37118A3B6EDL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFDEAD58449050L, 0x51EDD5200D1E0AD5L, 0x61D7766C56F1D70DL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFF4172C0D3BC9L, 0x3F95AB32D594401AL, 0x76D28C46DD0617E7L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFBC8B320D44DL, 0x4D3D57F8314D49FBL, 0x4527071F05690331L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFE858C7E6F1BL, 0x279EC75056618471L, 0x52E80FA22BA94282L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFF7C8EC707B0L, 0x6B55AB34EA98EAE2L, 0x1B0D0F13B4A2BCF3L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFD2C808E82DL, 0x1123C62C941EAD76L, 0x642F5A58AF659BAFL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFF097771644L, 0x41182560B0093DB0L, 0x6918915BFDD2078CL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFACCA80019L, 0x64183E62C1D1772FL, 0x7B7A5983BEF9C0D6L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFE42EB0C08L, 0x2D8F4FCDA2A420BEL, 0x20BE77BEADAB92C5L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFF6C9E38D1L, 0x73F2AA731E055A4FL, 0x77A2662E36213412L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFCFA9113BL, 0x46D62706061BD5C0L, 0x2D61E15F41817AA7L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFF04BBB22L, 0x606B8CC8FB594CC7L, 0x59FA3A12118B520AL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFAF256BCL, 0x3F390B90D09323EBL, 0x09791A1F7547D101L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFE63AD0BL, 0x5CF5D5735D2AB4F0L, 0x5ACBC06BD291D07AL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFF7DD4A1L, 0x15F9B4A06E9DC557L, 0x546DC2655FC0FE0DL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFD74BECL, 0x1B41BE0EC83C3390L, 0x0944FAB895C826DDL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFF364A9L, 0x747DCD7DEEBA863FL, 0x1251C251956CC608L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFC21ECL, 0x55F230B2C978FEADL, 0x5E55A4EB2248F19FL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFED327L, 0x576358AEF37CB07EL, 0x73D0412989AD4F5BL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFA574L, 0x2AD46396F5FE878EL, 0x77AEE142A17FEAE9L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFE501L, 0x79C59134EE697BFAL, 0x07C9429B059202E2L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFF807L, 0x5380BE12E6F37AC7L, 0x4153D841B0771352L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFDABL, 0x22E5C8BD25F128BEL, 0x29F5F5031E5ECB32L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFF53L, 0x11D73168E17750D0L, 0x1947168CFC0C3951L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFCEL, 0x3374DC4DCFF99F2AL, 0x36A73A09054C7971L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFF1L, 0x73C76A927CD33CC6L, 0x0F53B5B2CBCB998AL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFCL, 0x0421452F3BB92AAEL, 0x27C3A2D4D5C97482L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFEL, 0x72667ACC40B45B1CL, 0x35783FB2CB2EEF0FL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x58E5700779E7D751L, 0x18D6B51E1A569A36L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x754DD3C2B98F1A8FL, 0x6379C06E3E75C697L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7D1A297A753E71C8L, 0x1B53DC723614C24DL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7F38EE6FE76A6864L, 0x02351EC154A15348L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FCB16EB0B4A97B0L, 0x26A7A2AF6D6FA336L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FF21221807F5D34L, 0x7948BDD8B9329D9EL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFC5E30E758E9ADL, 0x27EFDA7B88D128A5L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFF0FDBE6FD9CA8L, 0x6F087E3AB8B5AD2FL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFC291D57C2174L, 0x796BE9F368F0B90BL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFF06F6A3759ABL, 0x4D2C4F87A75B0790L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFC1807CEB8CFL, 0x6406384C14673CB0L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFF07704E0894L, 0x07C8A2377A6D1FE1L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFC2CDD1D825L, 0x19E3264F14F51D45L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFF113B8006BL, 0x7FE679A9B35A6DD8L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFC6547B578L, 0x27EDE60CD4B88477L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFF2341D96CL, 0x6E39E1F4D4EC0C71L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFCBB1DDCEL, 0x6AB77C083C24F8C9L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFF3B96E21L, 0x4DF4C88324425294L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFD257D62L, 0x1C7AC9DA49D43805L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFF57CE82L, 0x053B8377065CEE6FL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFD9A4E4L, 0x12D317182A6EA575L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFF75621L, 0x27DD26B6A76C6EA9L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFE0FD1L, 0x47F2D0236CE7EEE7L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFF920DL, 0x3A71F49CD9A5457FL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFE7DEL, 0x4595C265B69633E3L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFAC1L, 0x1097D691ABA5B14CL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFEDEL, 0x6EF0E5F054DA0C07L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFC2L, 0x2B8ED462CB5CEEEBL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFF2L, 0x7CEDF9B2CA5365DFL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFDL, 0x233BA19970E4E0F3L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x37BAFA06718DAA6AL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x712AE07CF19AEB63L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7CFC1DB3E96A4A48L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7F64963F4F7AC456L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FE101D5BCB4BBCCL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FF9E0D78EFB9CC4L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFECD683A2BBFF5L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFC4976A26A0A1L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFF49924437A52L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFDD526C6950CL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFF9788D458A7L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFEC84E5C7F6L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFC66DEFCDAL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFF577D178BL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFE17776B5L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFA85331EL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFF06A5CAL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFD41987L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFF85844L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFEAD87L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFC619L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFF630L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFE5AL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFB9L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFF4L},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFEL},new[] {0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL, 0x7FFFFFFFFFFFFFFFL}};

		
		
		private static long modulus7(long number) {

			long temporary = number;

			for(int i = 0; i < 2; i++) {

				temporary = (temporary & 7) + (temporary >> 3);

			}

			return ((temporary - 7) >> 3) & temporary;

		}

		/// <summary>
		///     ****************************************************************************************************************
		///     Description:	Samples Polynomial Y, Such That Each Coefficient is in the Range [-B, B], for Heuristic qTESLA
		///     Security Category-1 and Security Category-3 (Option for Size or Speed)
		/// </summary>
		/// <param name="Y">                Polynomial Y </param>
		/// <param name="seed">            Kappa-Bit Seed </param>
		/// <param name="seedOffset">        Starting Point of the Kappa-Bit Seed </param>
		/// <param name="nonce">            Domain Separator for Error Polynomial and Secret Polynomial </param>
		/// <param name="n">                Polynomial Degree </param>
		/// <param name="q">                Modulus </param>
		/// <param name="b">                Determines the Interval the Randomness is Chosen in During Signing </param>
		/// <param name="bBit">
		///     b = 2 ^ bBit - 1
		/// </param>
		/// <returns>
		///     none
		///     *****************************************************************************************************************
		/// </returns>
		public static void sampleY(int[] Y, sbyte[] seed, int seedOffset, int nonce, int n, int q, int b, int bBit) {

			int i = 0;
			int position = 0;
			int numberOfByte = (bBit + 1 + 7) / 8;
			int numberOfBlock = n;
			sbyte[] buffer = new sbyte[n * numberOfByte];
			int[] y = new int[4];

			short dualModeSampler = (short) (nonce << 8);

			if(q == Parameter.Q_I) {

				HashUtils.customizableSecureHashAlgorithmKECCAK128Simple(buffer, 0, n * numberOfByte, dualModeSampler++, seed, seedOffset, Polynomial.RANDOM);

			}

			if((q == Parameter.Q_III)) {

				HashUtils.customizableSecureHashAlgorithmKECCAK256Simple(buffer, 0, n * numberOfByte, dualModeSampler++, seed, seedOffset, Polynomial.RANDOM);

			}

			if((q == Parameter.Q_V)) {

				HashUtils.customizableSecureHashAlgorithmKECCAK256Simple(buffer, 0, n * numberOfByte, dualModeSampler++, seed, seedOffset, Polynomial.RANDOM);

			}
			
			while(i < n) {

				if(position > (numberOfBlock * numberOfByte * 4)) {

					if(q == Parameter.Q_I) {

						numberOfBlock = HashUtils.SECURE_HASH_ALGORITHM_KECCAK_128_RATE / ((bBit + 1 + 7) / 8);

						HashUtils.customizableSecureHashAlgorithmKECCAK128Simple(buffer, 0, HashUtils.SECURE_HASH_ALGORITHM_KECCAK_128_RATE, dualModeSampler++, seed, seedOffset, Polynomial.RANDOM);

					}

					if((q == Parameter.Q_III)) {

						numberOfBlock = HashUtils.SECURE_HASH_ALGORITHM_KECCAK_256_RATE / ((bBit + 1 + 7) / 8);

						HashUtils.customizableSecureHashAlgorithmKECCAK256Simple(buffer, 0, HashUtils.SECURE_HASH_ALGORITHM_KECCAK_256_RATE, dualModeSampler++, seed, seedOffset, Polynomial.RANDOM);

					}
					
					if((q == Parameter.Q_V)) {

						numberOfBlock = HashUtils.SECURE_HASH_ALGORITHM_KECCAK_256_RATE / ((bBit + 1 + 7) / 8);

						HashUtils.customizableSecureHashAlgorithmKECCAK256Simple(buffer, 0, HashUtils.SECURE_HASH_ALGORITHM_KECCAK_256_RATE, dualModeSampler++, seed, seedOffset, Polynomial.RANDOM);

					}

					position = 0;

				}

				y[0] = (CommonFunction.load32(buffer, position) & ((1 << (bBit + 1)) - 1)) - b;
				y[1] = (CommonFunction.load32(buffer, position + numberOfByte) & ((1 << (bBit + 1)) - 1)) - b;
				y[2] = (CommonFunction.load32(buffer, position + (numberOfByte * 2)) & ((1 << (bBit + 1)) - 1)) - b;
				y[3] = (CommonFunction.load32(buffer, position + (numberOfByte * 3)) & ((1 << (bBit + 1)) - 1)) - b;

				if((i < n) && (y[0] != (1 << bBit))) {

					Y[i++] = y[0];

				}

				if((i < n) && (y[1] != (1 << bBit))) {

					Y[i++] = y[1];

				}

				if((i < n) && (y[2] != (1 << bBit))) {

					Y[i++] = y[2];

				}

				if((i < n) && (y[3] != (1 << bBit))) {

					Y[i++] = y[3];

				}

				position += numberOfByte * 4;

			}

		}

		/// <summary>
		///     *****************************************************************************************************************
		///     Description:	Samples Polynomial Y, Such That Each Coefficient is in the Range [-B, B], for Provably-Secure qTESLA
		///     Security Category-1 and Security Category-3
		/// </summary>
		/// <param name="Y">                Polynomial Y </param>
		/// <param name="seed">            Kappa-Bit Seed </param>
		/// <param name="seedOffset">        Starting Point of the Kappa-Bit Seed </param>
		/// <param name="nonce">            Domain Separator for Error Polynomial and Secret Polynomial </param>
		/// <param name="n">                Polynomial Degree </param>
		/// <param name="q">                Modulus </param>
		/// <param name="b">                Determines the Interval the Randomness is Chosen in During Signing </param>
		/// <param name="bBit">
		///     b = 2 ^ bBit - 1
		/// </param>
		/// <returns>
		///     none
		///     ******************************************************************************************************************
		/// </returns>
		public static void sampleY(long[] Y, sbyte[] seed, int seedOffset, int nonce, int n, int q, int b, int bBit) {

			int i = 0;
			int position = 0;
			int numberOfByte = (bBit + 1 + 7) / 8;
			int numberOfBlock = n;
			sbyte[] buffer = new sbyte[n * numberOfByte];

			short dualModeSampler = (short) (nonce << 8);

			if(q == Parameter.Q_I_P) {

				HashUtils.customizableSecureHashAlgorithmKECCAK128Simple(buffer, 0, n * numberOfByte, dualModeSampler++, seed, seedOffset, Polynomial.RANDOM);

			}

			if(q == Parameter.Q_III_P) {

				HashUtils.customizableSecureHashAlgorithmKECCAK256Simple(buffer, 0, n * numberOfByte, dualModeSampler++, seed, seedOffset, Polynomial.RANDOM);

			}

			while(i < n) {

				if(position > (numberOfBlock * numberOfByte)) {

					if(q == Parameter.Q_I_P) {

						numberOfBlock = HashUtils.SECURE_HASH_ALGORITHM_KECCAK_128_RATE / ((bBit + 1 + 7) / 8);

						HashUtils.customizableSecureHashAlgorithmKECCAK128Simple(buffer, 0, HashUtils.SECURE_HASH_ALGORITHM_KECCAK_128_RATE, dualModeSampler++, seed, seedOffset, Polynomial.RANDOM);

					}

					if(q == Parameter.Q_III_P) {

						numberOfBlock = HashUtils.SECURE_HASH_ALGORITHM_KECCAK_256_RATE / ((bBit + 1 + 7) / 8);

						HashUtils.customizableSecureHashAlgorithmKECCAK256Simple(buffer, 0, HashUtils.SECURE_HASH_ALGORITHM_KECCAK_256_RATE, dualModeSampler++, seed, seedOffset, Polynomial.RANDOM);

					}

					position = 0;

				}

				Y[i] = (CommonFunction.load32(buffer, position) & ((1 << (bBit + 1)) - 1)) - b;

				if(Y[i] != (1 << bBit)) {

					i++;

				}

				position += numberOfByte;

			}

		}

		/// <summary>
		///     ***************************************************************************************************************
		///     Description:	Samples A Bit from Bernoulli with Restriction of 20-Bit Exponent
		///     ****************************************************************************************************************
		/// </summary>
		private static int bernoulli(long result, long fractionOfExponent, double[][] exponentialDistribution) {

			/* *
			 * Computes the Actual Bernoulli Parameter = exp (-t / f)
			 * Yields A Fraction of 2^62, to Keep Only 62 Bits of Precision in This Implementation
			 * */
			double bernoulliParameter = 4611686018427387904.00;

			for(long i = 0, j = fractionOfExponent; i < 3; i++, j >>= 5) {

				bernoulliParameter *= exponentialDistribution[(int) i][(int) (j & 31)];

			}

			/* Sample from Bernoulli of bernoulliParameter */
			return (int) (((ulong) (result & 0x3FFFFFFFFFFFFFFFL) - (ulong) round(bernoulliParameter)) >> 63);

		}

		/// <summary>
		///     ********************************************************************************************************************
		///     Description:	Gaussian Sampler for Heuristic qTESLA Security Category-1
		/// </summary>
		/// <param name="data">                        Data to be Sampled </param>
		/// <param name="dataOffset">                    Starting Point of the Data to be Sampled </param>
		/// <param name="seed">                        Kappa-Bit Seed </param>
		/// <param name="seedOffset">                    Starting Point of the Kappa-Bit Seed </param>
		/// <param name="nonce">
		///     Domain Separator for Error Polynomial and Secret Polynomial
		/// </param>
		/// <returns>
		///     none
		///     *********************************************************************************************************************
		/// </returns>
		public static void polynomialGaussSamplerI(int[] data, int dataOffset, sbyte[] seed, int seedOffset, int nonce) {

			sbyte[] seedExpander = new sbyte[Parameter.N_I * Const.LONG_SIZE / Const.INT_SIZE];
			short domainSeparator = (short) (nonce << 8);
			int index;
			int j = 0;
			long k;
			long sign;
			long r;
			long s;
			long randomBit;
			long bitRemained;
			long y;
			long z;
			long buffer;

			try {
				HashUtils.customizableSecureHashAlgorithmKECCAK128Simple(seedExpander, 0, Parameter.N_I * Const.LONG_SIZE / Const.INT_SIZE, domainSeparator++, seed, seedOffset, Polynomial.RANDOM);

				for(index = 0; index < Parameter.N_I; index++) {

					if((j + 46) > Parameter.N_I) {

						HashUtils.customizableSecureHashAlgorithmKECCAK128Simple(seedExpander, 0, Parameter.N_I * Const.LONG_SIZE / Const.INT_SIZE, domainSeparator++, seed, seedOffset, Polynomial.RANDOM);

						j = 0;

					}

					do {

						randomBit = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
						bitRemained = 64;

						do {

							/* Sample x from D^+_{\SIGMA_2} and y from U ({0, ..., k - 1}) */
							do {

								r = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
								s = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);

								if(bitRemained <= (64 - 6)) {

									randomBit = (randomBit << 6) ^ ((long) ((ulong) r >> 58) & 63L);
									bitRemained += 6;

								}

								r &= 0x03FFFFFFFFFFFFFFL;

								/*
								 * Checks If r Exceeds A Maximum Value
								 * Variation is Random ad Does not Depend on Private Data
								 */
							} while(r > 0x0321020100200100L);

							y = 0;

							for(int i = 0; i < 12; i++) {

								long c = s - CUMULATIVE_DISTRIBUTION_TABLE_I[i][1];

								long b = (long) ((ulong) ((c & CUMULATIVE_DISTRIBUTION_TABLE_I[i][1] & 1) + (CUMULATIVE_DISTRIBUTION_TABLE_I[i][1] >> 1) + (long) ((ulong) c >> 1)) >> 63);

								c = r - (CUMULATIVE_DISTRIBUTION_TABLE_I[i][0] + b);

								y += ~(long) ((ulong) c >> 63) & 1L;

							}

							/* The Next Sampler Works Exclusively for xi <= 28 */
							do {

								do {

									if(bitRemained < 6) {

										randomBit = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
										bitRemained = 64;

									}

									z = randomBit & 63L;
									randomBit >>= 6;
									bitRemained -= 6;

								} while(z == 63);

								if(bitRemained < 2) {

									randomBit = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
									bitRemained = 64;

								}

								z = (modulus7(z) << 2) + (randomBit & 3L);
								randomBit >>= 2;
								bitRemained -= 2;

								/*
								 * Making Sure Random z Does not Exceed A Certain Limit
								 * No Private Data is Leaked
								 * It Varies Uniformly
								 */
							} while(z >= Parameter.XI_I);

							/* Sample A Bit from Bernoulli_{exp (- y * (y + 2 * k * x) / (2 * k^2 * SIGMA_2^2))} */
							k = (long) ((Parameter.XI_I * y) + z);

							buffer = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);

						} while(bernoulli(buffer, z * ((k << 1) - z), EXPONENTIAL_DISTRIBUTION_I) == 0);

						/* Put Last Random Bits into Sign Bit */
						randomBit <<= (int) (64 - bitRemained);

						if(bitRemained == 0) {

							randomBit = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
							bitRemained = 64;

						}

						sign = randomBit >> 63;
						randomBit <<= 1;
						bitRemained--;

					} while((k | (sign & 1L)) == 0);

					if(bitRemained == 0) {

						randomBit = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
						bitRemained = 64;

					}

					sign = randomBit >> 63;
					randomBit <<= 1;
					bitRemained--;
					k = ((k << 1) & sign) - k;
					data[dataOffset + index] = (int) ((k << 48) >> 48);

				}
			} catch {
				// sometimes an issue happens and we get here. ew just return and ignore it. it will loop again
				//TODO: investigate why we get here?
			}
		}

		/// <summary>
		///     ********************************************************************************************************************
		///     Description:	Gaussian Sampler for Provably-Secure qTESLA Security Category-1
		/// </summary>
		/// <param name="data">                        Data to be Sampled </param>
		/// <param name="dataOffset">                    Starting Point of the Data to be Sampled </param>
		/// <param name="seed">                        Kappa-Bit Seed </param>
		/// <param name="seedOffset">                    Starting Point of the Kappa-Bit Seed </param>
		/// <param name="nonce">
		///     Domain Separator for Error Polynomial and Secret Polynomial
		/// </param>
		/// <returns>
		///     none
		///     *********************************************************************************************************************
		/// </returns>
		public static void polynomialGaussSamplerIP(long[] data, int dataOffset, sbyte[] seed, int seedOffset, int nonce) {

			sbyte[] seedExpander = new sbyte[(Parameter.N_I_P * Const.LONG_SIZE) / Const.INT_SIZE];
			short domainSeparator = (short) (nonce << 8);
			int index;
			int j = 0;
			long k;
			long sign;
			long r;
			long s;
			long randomBit;
			long bitRemained;
			long y;
			long z;
			long buffer;

			try {
				HashUtils.customizableSecureHashAlgorithmKECCAK128Simple(seedExpander, 0, (Parameter.N_I_P * Const.LONG_SIZE) / Const.INT_SIZE, domainSeparator++, seed, seedOffset, Polynomial.RANDOM);

				for(index = 0; index < Parameter.N_I_P; index++) {

					if((j + 46) > Parameter.N_I_P) {

						HashUtils.customizableSecureHashAlgorithmKECCAK128Simple(seedExpander, 0, (Parameter.N_I_P * Const.LONG_SIZE) / Const.INT_SIZE, domainSeparator++, seed, seedOffset, Polynomial.RANDOM);

						j = 0;

					}

					do {

						randomBit = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
						bitRemained = 64;

						do {

							/* Sample x from D^+_{\SIGMA_2} and y from U ({0, ..., k - 1}) */
							do {

								r = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
								s = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);

								if(bitRemained <= (64 - 6)) {

									randomBit = (randomBit << 6) ^ ((long) ((ulong) r >> 58) & 63L);
									bitRemained += 6;

								}

								r &= 0x03FFFFFFFFFFFFFFL;

								/*
								 * Checks If r Exceeds A Maximum Value
								 * Variation is Random ad Does not Depend on Private Data
								 */
							} while(r > 0x0321020100200100L);

							y = 0;

							for(int i = 0; i < 12; i++) {

								long c = s - CUMULATIVE_DISTRIBUTION_TABLE_I[i][1];

								long b = (long) ((ulong) ((c & CUMULATIVE_DISTRIBUTION_TABLE_I[i][1] & 1) + (CUMULATIVE_DISTRIBUTION_TABLE_I[i][1] >> 1) + (long) ((ulong) c >> 1)) >> 63);

								c = r - (CUMULATIVE_DISTRIBUTION_TABLE_I[i][0] + b);

								y += ~(long) ((ulong) c >> 63) & 1L;

							}

							/* The Next Sampler Works Exclusively for xi <= 28 */
							do {

								do {

									if(bitRemained < 6) {

										randomBit = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
										bitRemained = 64;

									}

									z = randomBit & 63L;
									randomBit >>= 6;
									bitRemained -= 6;

								} while(z == 63);

								if(bitRemained < 2) {

									randomBit = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
									bitRemained = 64;

								}

								z = (modulus7(z) << 2) + (randomBit & 3L);
								randomBit >>= 2;
								bitRemained -= 2;

								/*
								 * Making Sure Random z Does not Exceed A Certain Limit
								 * No Private Data is Leaked
								 * It Varies Uniformly
								 */
							} while(z >= Parameter.XI_I_P);

							/* Sample A Bit from Bernoulli_{exp (- y * (y + 2 * k * x) / (2 * k^2 * SIGMA_2^2))} */
							k = (long) ((Parameter.XI_I_P * y) + z);

							buffer = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);

						} while(bernoulli(buffer, z * ((k << 1) - z), EXPONENTIAL_DISTRIBUTION_P) == 0);

						/* Put Last Random Bits into Sign Bit */
						randomBit <<= (int) (64 - bitRemained);

						if(bitRemained == 0) {

							randomBit = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
							bitRemained = 64;

						}

						sign = randomBit >> 63;
						randomBit <<= 1;
						bitRemained--;

					} while((k | (sign & 1L)) == 0);

					if(bitRemained == 0) {

						randomBit = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
						bitRemained = 64;

					}

					sign = randomBit >> 63;
					randomBit <<= 1;
					bitRemained--;
					k = ((k << 1) & sign) - k;
					data[dataOffset + index] = (k << 48) >> 48;

				}
			} catch {
				// sometimes an issue happens and we get here. ew just return and ignore it. it will loop again
				//TODO: investigate why we get here?
			}
		}

		/// <summary>
		///     *****************************************************************************************************************************************************************************
		///     Description:	Gaussian Sampler for Heuristic qTESLA Security Category-3 (Option for Size or Speed)
		/// </summary>
		/// <param name="data">                        Data to be Sampled </param>
		/// <param name="dataOffset">                    Starting Point of the Data to be Sampled </param>
		/// <param name="seed">                        Kappa-Bit Seed </param>
		/// <param name="seedOffset">                    Starting Point of the Kappa-Bit Seed </param>
		/// <param name="nonce">                        Domain Separator for Error Polynomial and Secret Polynomial </param>
		/// <param name="n">                            Polynomial Degree </param>
		/// <param name="xi"> </param>
		/// <param name="exponentialDistribution">
		///     Exponential Distribution Table
		/// </param>
		/// <returns>
		///     none
		///     ******************************************************************************************************************************************************************************
		/// </returns>
		public static void polynomialGaussSamplerIII(int[] data, int dataOffset, sbyte[] seed, int seedOffset, int nonce, int n, double xi, double[][] exponentialDistribution) {

			sbyte[] seedExpander = new sbyte[(n * Const.LONG_SIZE) / Const.INT_SIZE];
			short domainSeparator = (short) (nonce << 8);
			int index;
			int j = 0;
			long k;
			long sign;
			long r;
			long s;
			long t;
			long randomBit;
			long bitRemained;
			long y;
			long z;

			try {
				HashUtils.customizableSecureHashAlgorithmKECCAK256Simple(seedExpander, 0, (n * Const.LONG_SIZE) / Const.INT_SIZE, domainSeparator++, seed, seedOffset, Polynomial.RANDOM);

				for(index = 0; index < n; index++) {

					if((j + 46) > n) {

						HashUtils.customizableSecureHashAlgorithmKECCAK256Simple(seedExpander, 0, (n * Const.LONG_SIZE) / Const.INT_SIZE, domainSeparator++, seed, seedOffset, Polynomial.RANDOM);

						j = 0;

					}

					do {

						randomBit = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
						bitRemained = 64;

						do {

							/* Sample x from D^+_{\SIGMA_2} and y from U ({0, ..., k - 1}) */
							do {

								r = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
								s = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
								t = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);

								if(bitRemained <= (64 - 6)) {

									randomBit = (randomBit << 6) ^ ((long) ((ulong) r >> 58) & 63L);
									bitRemained += 6;

								}

								r &= 0x000003FFFFFFFFFFL;

								/*
								 * Checks If r Exceeds A Maximum Value
								 * Variation is Random ad Does not Depend on Private Data
								 */
							} while(r > 0x0000032102010020L);

							y = 0;

							for(int i = 0; i < 14; i++) {

								long c = t - CUMULATIVE_DISTRIBUTION_TABLE_III[i][2];

								long b = ((c & CUMULATIVE_DISTRIBUTION_TABLE_III[i][2] & 1L) + (CUMULATIVE_DISTRIBUTION_TABLE_III[i][2] >> 1) + (long) ((ulong) c >> 1)) >> 63;

								/* Least significant Bits of All CUMULATIVE_DISTRIBUTION_TABLE[i][1] are Zero: Overflow Cannot Occur at This Point */
								c = s - (CUMULATIVE_DISTRIBUTION_TABLE_III[i][1] + b);

								b = ((c & b & 1L) + (CUMULATIVE_DISTRIBUTION_TABLE_III[i][1] >> 1) + (long) ((ulong) c >> 1)) >> 63;

								/* Least significant Bits of All CUMULATIVE_DISTRIBUTION_TABLE[i][0] are Zero: Overflow Cannot Occur at This Point */
								c = r - (CUMULATIVE_DISTRIBUTION_TABLE_III[i][0] + b);

								y += ~(long) ((ulong) c >> 63) & 1L;

							}

							/* The Next Sampler Works Exclusively for xi <= 28 */
							do {

								do {

									if(bitRemained < 6) {

										randomBit = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
										bitRemained = 64;

									}

									z = randomBit & 63L;
									randomBit >>= 6;
									bitRemained -= 6;

								} while(z == 63L);

								if(bitRemained < 2) {

									randomBit = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
									bitRemained = 64;

								}

								z = (modulus7(z) << 2) + (randomBit & 3L);
								randomBit >>= 2;
								bitRemained -= 2;

								/*
								 * Making Sure Random z Does not Exceed A Certain Limit
								 * No Private Data is Leaked
								 * It Varies Uniformly
								 */
							} while(z >= xi);

							/* Sample A Bit from Bernoulli_{exp (- y * (y + 2 * k * x) / (2 * k^2 * SIGMA_2^2))} */
							k = (long) ((xi * y) + z);

						} while(bernoulli(CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE), z * ((k << 1) - z), exponentialDistribution) == 0);

						/* Put Last Random Bits into Sign Bit */
						randomBit <<= (int) (64 - bitRemained);

						if(bitRemained == 0L) {

							randomBit = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
							bitRemained = 64;

						}

						sign = randomBit >> 63;
						randomBit <<= 1;
						bitRemained--;

					} while((k | (sign & 1L)) == 0);

					if(bitRemained == 0) {

						randomBit = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
						bitRemained = 64;

					}

					sign = randomBit >> 63;
					randomBit <<= 1;
					bitRemained--;
					k = ((k << 1) & sign) - k;
					data[dataOffset + index] = (int) ((k << 48) >> 48);

				}
			} catch {
				// sometimes an issue happens and we get here. ew just return and ignore it. it will loop again
				//TODO: investigate why we get here?
			}

		}
		
		/// <summary>
		///     *****************************************************************************************************************************************************************************
		///     Description:	Gaussian Sampler for Heuristic qTESLA Security Category-3 (Option for Size or Speed)
		/// </summary>
		/// <param name="data">                        Data to be Sampled </param>
		/// <param name="dataOffset">                    Starting Point of the Data to be Sampled </param>
		/// <param name="seed">                        Kappa-Bit Seed </param>
		/// <param name="seedOffset">                    Starting Point of the Kappa-Bit Seed </param>
		/// <param name="nonce">                        Domain Separator for Error Polynomial and Secret Polynomial </param>
		/// <param name="n">                            Polynomial Degree </param>
		/// <param name="xi"> </param>
		/// <param name="exponentialDistribution">
		///     Exponential Distribution Table
		/// </param>
		/// <returns>
		///     none
		///     ******************************************************************************************************************************************************************************
		/// </returns>
		public static void polynomialGaussSamplerV(int[] data, int dataOffset, sbyte[] seed, int seedOffset, int nonce, int n, double xi, double[][] exponentialDistribution) {

			sbyte[] seedExpander = new sbyte[(n * Const.LONG_SIZE) / Const.INT_SIZE];
			short domainSeparator = (short) (nonce << 8);
			int index;
			int j = 0;
			long k;
			long sign;
			long r;
			long s;
			long t;
			long v;
			long randomBit;
			long bitRemained;
			long y;
			long z;

			try {
				HashUtils.customizableSecureHashAlgorithmKECCAK256Simple(seedExpander, 0, (n * Const.LONG_SIZE) / Const.INT_SIZE, domainSeparator++, seed, seedOffset, Polynomial.RANDOM);

				for(index = 0; index < n; index++) {

					if((j + 46) > n) {

						HashUtils.customizableSecureHashAlgorithmKECCAK256Simple(seedExpander, 0, (n * Const.LONG_SIZE) / Const.INT_SIZE, domainSeparator++, seed, seedOffset, Polynomial.RANDOM);

						j = 0;

					}

					do {

						randomBit = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
						bitRemained = 64;

						do {

							/* Sample x from D^+_{\SIGMA_2} and y from U ({0, ..., k - 1}) */
							do {

								r = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
								s = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
								t = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
								v = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);

								if(bitRemained <= (64 - 6)) {

									randomBit = (randomBit << 6) ^ ((long) ((ulong) r >> 58) & 63L);
									bitRemained += 6;

								}

								r &= 0x000003FFFFFFFFFFL;

								/*
								 * Checks If r Exceeds A Maximum Value
								 * Variation is Random ad Does not Depend on Private Data
								 */
							} while(r > 0x0000032102010020L);

							y = 0;

							for(int i = 0; i < 14; i++) {

								long c = v - CUMULATIVE_DISTRIBUTION_TABLE_V[i][3];

								long b = ((c & CUMULATIVE_DISTRIBUTION_TABLE_V[i][3] & 1L) + (CUMULATIVE_DISTRIBUTION_TABLE_V[i][3] >> 1) + (long) ((ulong) c >> 1)) >> 63;
								
								/* Least significant Bits of All CUMULATIVE_DISTRIBUTION_TABLE[i][1] are Zero: Overflow Cannot Occur at This Point */
								c = t - (CUMULATIVE_DISTRIBUTION_TABLE_V[i][2] + b);

								b = ((c & b & 1L) + (CUMULATIVE_DISTRIBUTION_TABLE_V[i][2] >> 1) + (long) ((ulong) c >> 1)) >> 63;

								/* Least significant Bits of All CUMULATIVE_DISTRIBUTION_TABLE[i][1] are Zero: Overflow Cannot Occur at This Point */
								c = s - (CUMULATIVE_DISTRIBUTION_TABLE_V[i][1] + b);

								b = ((c & b & 1L) + (CUMULATIVE_DISTRIBUTION_TABLE_V[i][1] >> 1) + (long) ((ulong) c >> 1)) >> 63;

								/* Least significant Bits of All CUMULATIVE_DISTRIBUTION_TABLE[i][0] are Zero: Overflow Cannot Occur at This Point */
								c = r - (CUMULATIVE_DISTRIBUTION_TABLE_V[i][0] + b);

								y += ~(long) ((ulong) c >> 63) & 1L;

							}

							/* The Next Sampler Works Exclusively for xi <= 28 */
							do {

								do {

									if(bitRemained < 6) {

										randomBit = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
										bitRemained = 64;

									}

									z = randomBit & 63L;
									randomBit >>= 6;
									bitRemained -= 6;

								} while(z == 63L);

								if(bitRemained < 2) {

									randomBit = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
									bitRemained = 64;

								}

								z = (modulus7(z) << 2) + (randomBit & 3L);
								randomBit >>= 2;
								bitRemained -= 2;

								/*
								 * Making Sure Random z Does not Exceed A Certain Limit
								 * No Private Data is Leaked
								 * It Varies Uniformly
								 */
							} while(z >= xi);

							/* Sample A Bit from Bernoulli_{exp (- y * (y + 2 * k * x) / (2 * k^2 * SIGMA_2^2))} */
							k = (long) ((xi * y) + z);

						} while(bernoulli(CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE), z * ((k << 1) - z), exponentialDistribution) == 0);

						/* Put Last Random Bits into Sign Bit */
						randomBit <<= (int) (64 - bitRemained);

						if(bitRemained == 0L) {

							randomBit = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
							bitRemained = 64;

						}

						sign = randomBit >> 63;
						randomBit <<= 1;
						bitRemained--;

					} while((k | (sign & 1L)) == 0);

					if(bitRemained == 0) {

						randomBit = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
						bitRemained = 64;

					}

					sign = randomBit >> 63;
					randomBit <<= 1;
					bitRemained--;
					k = ((k << 1) & sign) - k;
					data[dataOffset + index] = (int) ((k << 48) >> 48);

				}
			} catch {
				// sometimes an issue happens and we get here. ew just return and ignore it. it will loop again
				//TODO: investigate why we get here?
			}

		}

		/// <summary>
		///     ************************************************************************************************************************
		///     Description:	Gaussian Sampler for Provably-Secure qTESLA Security Category-3
		/// </summary>
		/// <param name="data">                        Data to be Sampled </param>
		/// <param name="dataOffset">                    Starting Point of the Data to be Sampled </param>
		/// <param name="seed">                        Kappa-Bit Seed </param>
		/// <param name="seedOffset">                    Starting Point of the Kappa-Bit Seed </param>
		/// <param name="nonce">
		///     Domain Separator for Error Polynomial and Secret Polynomial
		/// </param>
		/// <returns>
		///     none
		///     *************************************************************************************************************************
		/// </returns>
		public static void polynomialGaussSamplerIIIP(long[] data, int dataOffset, sbyte[] seed, int seedOffset, int nonce) {

			//TODO: there is a random issue here. fix it!

			sbyte[] seedExpander = new sbyte[(Parameter.N_III_P * Const.LONG_SIZE) / Const.INT_SIZE];
			short domainSeparator = (short) (nonce << 8);
			int index;
			int j = 0;
			long k;
			long sign;
			long r;
			long s;
			long t;
			long randomBit = 0;
			long bitRemained;
			long y;
			long z;
			long buffer;

			try {
				HashUtils.customizableSecureHashAlgorithmKECCAK256Simple(seedExpander, 0, (Parameter.N_III_P * Const.LONG_SIZE) / Const.INT_SIZE, domainSeparator++, seed, seedOffset, Polynomial.RANDOM);

				for(index = 0; index < Parameter.N_III_P; index++) {

					if(index == 956) {
						int dd = 0;
					}

					if((j + 46) > Parameter.N_III_P) {

						HashUtils.customizableSecureHashAlgorithmKECCAK256Simple(seedExpander, 0, (Parameter.N_III_P * Const.LONG_SIZE) / Const.INT_SIZE, domainSeparator++, seed, seedOffset, Polynomial.RANDOM);

						j = 0;

					}

					do {

						randomBit = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);

						bitRemained = 64;

						do {

							/* Sample x from D^+_{\SIGMA_2} and y from U ({0, ..., k - 1}) */
							do {

								r = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
								s = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
								t = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);

								if(bitRemained <= (64 - 6)) {

									randomBit = (randomBit << 6) ^ ((long) ((ulong) r >> 58) & 63L);
									bitRemained += 6;

								}

								r &= 0x000003FFFFFFFFFFL;

								/*
								 * Checks If r Exceeds A Maximum Value
								 * Variation is Random ad Does not Depend on Private Data
								 */
							} while(r > 0x0000032102010020L);

							y = 0;

							for(int i = 0; i < 14; i++) {

								long c = t - CUMULATIVE_DISTRIBUTION_TABLE_III[i][2];

								long b = ((c & CUMULATIVE_DISTRIBUTION_TABLE_III[i][2] & 1L) + (CUMULATIVE_DISTRIBUTION_TABLE_III[i][2] >> 1) + (long) ((ulong) c >> 1)) >> 63;

								/* Least significant Bits of All CUMULATIVE_DISTRIBUTION_TABLE[i][1] are Zero: Overflow Cannot Occur at This Point */
								c = s - (CUMULATIVE_DISTRIBUTION_TABLE_III[i][1] + b);

								b = ((c & b & 1L) + (CUMULATIVE_DISTRIBUTION_TABLE_III[i][1] >> 1) + (long) ((ulong) c >> 1)) >> 63;

								/* Least significant Bits of All CUMULATIVE_DISTRIBUTION_TABLE[i][0] are Zero: Overflow Cannot Occur at This Point */
								c = r - (CUMULATIVE_DISTRIBUTION_TABLE_III[i][0] + b);

								y += ~(long) ((ulong) c >> 63) & 1L;

							}

							/* The Next Sampler Works Exclusively for xi <= 28 */
							do {

								do {

									if(bitRemained < 6) {

										randomBit = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
										bitRemained = 64;

									}

									z = randomBit & 63L;
									randomBit >>= 6;
									bitRemained -= 6;

								} while(z == 63L);

								if(bitRemained < 2) {

									randomBit = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
									bitRemained = 64;

								}

								z = (modulus7(z) << 2) + (randomBit & 3L);
								randomBit >>= 2;
								bitRemained -= 2;

								/*
								 * Making Sure Random z Does not Exceed A Certain Limit
								 * No Private Data is Leaked
								 * It Varies Uniformly
								 */
							} while(z >= Parameter.XI_III_P);

							/* Sample A Bit from Bernoulli_{exp (- y * (y + 2 * k * x) / (2 * k^2 * SIGMA_2^2))} */
							k = (long) ((Parameter.XI_III_P * y) + z);

							buffer = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
						} while(bernoulli(buffer, z * ((k << 1) - z), EXPONENTIAL_DISTRIBUTION_P) == 0);

						/* Put Last Random Bits into Sign Bit */
						randomBit <<= (int) (64 - bitRemained);

						if(bitRemained == 0L) {

							randomBit = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
							bitRemained = 64;

						}

						sign = randomBit >> 63;
						randomBit <<= 1;
						bitRemained--;

					} while((k | (sign & 1L)) == 0);

					if(bitRemained == 0) {

						randomBit = CommonFunction.load64(seedExpander, (j++) * Const.LONG_SIZE / Const.INT_SIZE);
						bitRemained = 64;

					}

					sign = randomBit >> 63;
					randomBit <<= 1;
					bitRemained--;
					k = ((k << 1) & sign) - k;
					data[dataOffset + index] = (k << 48) >> 48;

				}
			} catch {
				// sometimes an issue happens and we get here. ew just return and ignore it. it will loop again
				//TODO: investigate why we get here?
			}

		}

		/// <summary>
		///     ***********************************************************************************************************************
		///     Description:	Encoding of C' by Mapping the Output of the Hash Function H to An N-Element Vector with Entries {-1,
		///     0, 1}
		/// </summary>
		/// <param name="positionList">            {0, ..., n - 1} ^ h </param>
		/// <param name="signList">            {-1, +1} ^ h </param>
		/// <param name="output">                Result of the Hash Function H </param>
		/// <param name="outputOffset">        Starting Point of the Result of the Hash Function H </param>
		/// <param name="n">                    Polynomial Degree </param>
		/// <param name="h">
		///     Number of Non-Zero Entries of Output Elements of Encryption
		/// </param>
		/// <returns>
		///     none
		///     ************************************************************************************************************************
		/// </returns>
		public static void encodeC(int[] positionList, short[] signList, sbyte[] output, int outputOffset, int n, int h) {

			int count = 0;
			int position;
			short domainSeparator = 0;
			short[] C = new short[n];
			sbyte[] randomness = new sbyte[HashUtils.SECURE_HASH_ALGORITHM_KECCAK_128_RATE];

			/* Use the Hash Value as Key to Generate Some Randomness */
			HashUtils.customizableSecureHashAlgorithmKECCAK128Simple(randomness, 0, HashUtils.SECURE_HASH_ALGORITHM_KECCAK_128_RATE, domainSeparator++, output, outputOffset, Polynomial.RANDOM);

			/* Use Rejection Sampling to Determine Positions to be Set in the New Vector */
			ArraysExtensions.Fill(C, (short) 0);

			/* Sample A Unique Position k times.
			 * Use Two Bytes
			 */
			for(int i = 0; i < h;) {

				if(count > (HashUtils.SECURE_HASH_ALGORITHM_KECCAK_128_RATE - 3)) {

					HashUtils.customizableSecureHashAlgorithmKECCAK128Simple(randomness, 0, HashUtils.SECURE_HASH_ALGORITHM_KECCAK_128_RATE, domainSeparator++, output, outputOffset, Polynomial.RANDOM);

					count = 0;

				}

				position = (randomness[count] << 8) | (randomness[count + 1] & 0xFF);
				position &= n - 1;

				/* Position is between [0, n - 1] and Has not Been Set Yet
				 * Determine Signature
				 */
				if(C[position] == 0) {

					if((randomness[count + 2] & 1) == 1) {

						C[position] = -1;

					} else {

						C[position] = 1;

					}

					positionList[i] = position;
					signList[i] = C[position];
					i++;

				}

				count += 3;

			}

		}

		private static long round(double v) {
			if(v < 0) {
				return (long) (v - 0.5);
			} else {
				return (long) (v + 0.5);
			}
		}
	}
}